#include <stdlib.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <time.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>
#include <signal.h>
       
#define SERVER_PORT 8764

void handle(int fd, const char *str);

typedef struct _list {
   char *cmd;
   struct _list *next;
} list;

const char *cmds[] = {
   "/bin/ls", "/bin/pwd", "/bin/date",  "/usr/bin/id", "/usr/bin/whoami",
   NULL
};

char **env;

list *head;
list *tail;

int done = 0;

void sig_int_handler(int sig) {
   if (sig == SIGINT) {
      done = 1;
   }
}

void list_insert(char *cmd) {
   list *node = (list*)malloc(sizeof(list));
   node->cmd = cmd;
   node->next = NULL;
   if (tail) {
      tail->next = node;
   }
   else {
      head = node;
   }
   tail = node;
}

void list_clear() {
   list *next;
   while (head) {
      next = head->next;
      free(head->cmd);
      free(head);
      head = next;
   }
   tail = NULL;
}

void list_print(int fd) {
   list *n;
   for (n = head; n; n = n->next) {
      dprintf(fd, "%s\n", n->cmd);
   }
}

char *get_cmd(int client, char *buf) {
   char ch;
   int i = 0;
   while (1) {
      if (read(client, &ch, 1) != 1) {
         break;
      }
      if (ch == '\n') {
         break;
      }
      buf[i++] = ch;
   }
   buf[i] = 0;
   return buf;
}

void handle(int client, const char *cmd);

void handleClient(int client) {
   char buf[256];
   while (1) {
      dprintf(client, "$ ");
      list_insert(strdup(get_cmd(client, buf)));
      if (strcmp(tail->cmd, "history") == 0) {
         list_print(client);
      }
      else if (strcmp(tail->cmd, "history -c") == 0) {
         list_clear();
      }
      else if (strcmp(tail->cmd, "exit") == 0) {
         break;
      }
      else if (strncmp(tail->cmd, "echo ", 5) == 0) {
         dprintf(client, "%s\n", tail->cmd + 5);
      }
      else {
         int i;
         for (i = 0; cmds[i]; i++) {
            char *s = strstr(cmds[i], tail->cmd);
            if (s && s[strlen(tail->cmd)] == 0 && s[-1] == '/') {
               handle(client, cmds[i]);
               break;
            }
         }
         if (cmds[i] == NULL) {
            dprintf(client, "command not found\n");
         }
      }
   }
}

void my_daemon(int nochdir, int noclose) {
   if (fork() == 0) {
      setsid();
      if (!nochdir) {
         chdir("/");
      }
      if (!noclose) {
         close(0);
         close(1);
         close(2);
         open("/dev/null", O_RDONLY);
         open("/dev/null", O_WRONLY);
         open("/dev/null", O_WRONLY);
      }
   }
   else {
      _exit(0);
   }
}

int main(int argc, char **argv, char **envp) {
   struct sockaddr_in sa;
   int one = 1;
   env = envp;

   signal(SIGINT, sig_int_handler);
   signal(SIGCHLD, SIG_IGN);
   
   memset(&sa, 0, sizeof(sa));
   sa.sin_family = AF_INET;
   sa.sin_port = htons(SERVER_PORT);

   int serv = socket(AF_INET, SOCK_STREAM, 0);
   if (serv == -1) {perror("socket"); exit(1);}

   setsockopt(serv, SOL_SOCKET, SO_REUSEADDR, &one, sizeo f(one));
   
   if (bind(serv, (struct sockaddr*)&sa, sizeof(sa))) {
      perror("bind"); 
      exit(1);
   }

   if (listen(serv, 10)) {
      perror("listen"); 
      exit(1);
   }
   
   my_daemon(1, 0);
   
   while (!done) {
      int csock;
      csock = accept(serv, NULL, NULL);
      if (fork() == 0) {
         close(serv);
         handleClient(csock);
         close(csock);
         exit(0);
      }
      else {
         close(csock);
      }
   }
   close(serv);
}
